Approach: Let's sculpt.


1. Large blobs: describe what unique information is needed
    - Tagging legend, recipe config, style config
    - Tool that generates a recipe
    - Tool that generates a CSS file
    - Tool that generates a CNXML validator
    - Tool that generates a Styleguide
1. Smaller blob: describe when we want things to error
    - When tagging legend changes
    - When recipe config changes
    - When style config changes
1. Other development features
    - when so many files are autogenerated do we need a way to go back to the source? Sourcemaps?
1. Discuss JSX & move to XSLT (templates, creating elements, slots that recurse)


# Spike idea

Below, I'm describing what is in the input files and what the output files should contain


## Input Files

### Tagging legend

This should **only** define any book-specific markup in the CNXML.

```r
# File: physics.tagging

# *************************
# Notes can have "check-understanding" or "tip"
# *************************
element note {
    attribute class { "check-understanding" | "tip" }
}
element exercise {
    attribute class = "homework-problems"
}
```

### Recipe config

This file(s) should **only** describe how elements are numbered, moved, or text that is injected (like titles)

```ts
// File: physics.recipe.ts
checkUnderstanding: {
    title: "Check Your Understanding",
    numbering: NONE
}
tip: {
    numbering: NONE
}
homeworkProblems: {
    title: "Homework Problems"
    moveTo: END_CHAPTER
}
```

### Style config

This file(s) should **only** describe how things in the book are styled. The things in a book are both book-specific features as well as generic book things (ToC, Index, Chapter Introduction, etc).

```ts
// File: physics.style.ts
checkUnderstanding.title.style = { color: blue }
homeworkProblems.style = {border: 1px solid green }
```

## Frameworks

These things are the helpers that convert the input files into the output files. They do not have anything that is book-specific in them.

- Recipe Framework
- Style Framework
- Styleguide generator
- Validation generator


## Output Files

These are files that we would like to be autogenerated from the input files.

The gist of each file is included as a comment at the top of the file.

### CNXML Validation

```xml
<!-- File: physics.cnxml.grammar.rng -->
<!-- **************************************************
    This says that valid notes in CNXML must have a 
    class="check-understanding" or class="tip".
    Any other type of note is invalid. 
    Same for exercises.
    ************************************************** -->
<r:grammar xmlns:r="http://relaxng.org/ns/structure/1.0">
    <r:define name="Content.Note">
        <r:element name="note">
            <r:attribute name="class">
                <r:choice>
                    <r:value>check-understanding</r:value>
                    <r:value>tip</r:value>
                </r:choice>
            </r:attribute>
        </r:element>
    </r:define>
    <r:define name="Content.Exercise">
        <r:element name="exercise">
            <r:attribute name="class">
                <r:choice>
                    <r:value>homework-problems</r:value>
                </r:choice>
            </r:attribute>
        </r:element>
    </r:define>
</r:grammar>
```

And we may want an autogenerated-but-human-readable version too... something like https://github.com/openstax/cnxml/pull/9

### Recipe

Here is an example autogenerated recipe that could be generated from the recipe config above. I'm using XSLT here because it's concise and looks JSX'y

```xml
<!-- File: physics.autogen.recipe.xsl -->
<!-- **************************************************
    This says that the following things will happen:
    
    - check-understanding notes will get a "Check Your Understanding" title.
    - check-understanding notes will not be numbered
    - other notes will be numbered as {chapter}.{note_number}
    - the end of the chapter will contain a new "Homework Problems" section
      - This section will contain all the exercises in the chapter that have
        class="homework-problems"
    - the homework-problems will be removed from their original location
      since they were moved into the end-of-chapter area
    ************************************************** -->
<xsl:template match="note[classContains(., 'check-understanding')]">
    <div class="check-understanding123">
        <h3>Check Your Understanding</h3>
        <xsl:recurse/>
    </div>
</xsl:template>

<xsl:template match="note[classContains(., 'check-understanding')]" mode="numberize"><!-- Do not add a number --></xsl:template>

<!-- just show that we number all other notes as 3.4 -->
<xsl:template match="note" mode="numberize">{key('chapter', .)}.{key('note', .)}</xsl:template>

<xsl:template match="chapter">
    <xsl:copy>
        <!-- ... slot that recursively does chapter stuff -->
        <xsl:recurse/>

        <!-- end-of-chapter areas -->
        <section class="homework-problems456-clump">
            <h2>Homework Problems</h2>
            <xsl:apply-templates select=".//exercise[classContains(., 'homework-problems')]"/>
        </section>
    </xsl:copy>
</xsl:template>

<xsl:template match="chapter//exercise[classContains(., 'homework-problems')]">
    <!-- this removes the exercise from the original location -->
</xsl:template>

<!-- xsl:recurse is just shorthand for `<xsl:apply-templates select="@*|node()"/>` -->
```

### Style CSS

```less
// physics-pdf.autogen.css
.check-understanding123 h3 { color: blue }
.homework-problems456 { border: 1px solid green }
```

### Styleguide

Here is what an example autogenerated styleguide could look like.
To create the file we need the following pieces of information:

- the tagging legend : to know all of the book-specific things in the markup
- a baked example of each item in the tagging legend
- the generated CSS so we can style the feature

```html
<head>
    <link rel="stylesheet" href="physics-pdf.autogen.css"/>
</head>
<body>
<article>
    <h1>Here is what a "check-understanding" Note looks like</h1>

    <div class="check-understanding123">
        <h3>Check Your Understanding</h3>
        Lorem ipsum Non ea vel et aut nihil amet voluptatem eos. Veritatis impedit repellendus eius repellendus eaque quidem. Iure quo reiciendis atque aliquam quidem. Sed suscipit dolorum nisi sequi. Quo et eum dicta blanditiis et et dolore magnam
    </div>
</article>

<article>
    <h1>Here is what a "homework-problems" Exercise will look like</h1>

    <section class="homework-problems456-clump">
        <h2>Homework Problems</h2>
        <div class="homework-problems456">
            <div data-type="problem">
                Lorem ipsum Non ea vel et aut nihil amet voluptatem eos. Veritatis impedit repellendus eius repellendus eaque quidem. Iure quo reiciendis atque aliquam quidem. Sed suscipit dolorum nisi sequi. Quo et eum dicta blanditiis et et dolore magnam
            </div>
        </div>
    </section>
</article>
```

---

# Another Replacer Draft

I was thinking about XSLT and how if you squint hard enough it looks like CSS with JSX inside:

Add class "jam", wrap the contents with a "os-wrapper"

```less
.foo {
    <this classAdd="jam">
        <span class="os-wrapper">
            {...this.children}
        </span>
    </this>
}
```

Instead of manually keeping the recipe class name and the style class name in sync, we could do this which autogenerates the class names:


```less
.foo {
    <this classAdd="jam">
        <span style={color: blue}> // Or <span style={jamWrapper}> which is defined elsewhere
            {...this.children}
        </span>
    </this>
}
```



But after a few attempts to do something more complicated the limits of this syntax were starting to show...


This moves the solution and adds a link back to the exercise (it explores nested selectors and using more CSS syntax like `var` and `content`)

```less
[data-type="exercise"] {
    var linker: getLinkerToMe(this.attributes['id']);
    content: <this>
        <a href={linker.href}>{}
    
    [data-type="solution"] {
        <this id={linker.id}>
            {...this.children}
        </this>
    }
}


[data-type="chapter"] {

    var exercises: replaceAndMove(`[data-type="exercise"]`)

    <this>
        <div>
            <title>Homework</title>
            {...exercises}
        </div>
    </this>

}
```


## JSX, callbacks, and buckets

This code seems like a good candidate for parallelization (& memoization).
It follows the `describe(...)` and `it(...)` pattern of javascript unit tests which allows them to run in parallel (callbacks)


Here are the types:

```typescript
interface DomEl {
    // Replace anything that matches sel with the result of `cb()`
    replace(sel: String, cb: CallbackFn)
    
    // Same as replace(...) but move the result into the bucket
    replaceAndMove(b: Bucket, sel: String, cb: CallbackFn)
    
    // Creates a bucket that will be filled and must be used
    createBucket(): Bucket
    
    // Creates a counter that resets at `this` and increments whenever `sel` occurs
    createCounter(sel: String): Counter

    // Determines the number that should be shown 
    countOf(c: Coutner): TokenFn

    // uses the id attribute to construct `#{this.attributes['id']}` or generates an id attribute if one does not exist
    getHrefToMe(): String

    find(sel: String): DomEl
}

type CallbackFn = (this: DomEl) => void
type TokenFn = () => string

type Counter = {} // Opaque; just a token/symbol for the user

interface Bucket {
    dump(): Array<JsxEl>
}

interface JsxEl {
    constructor(el: DomEl, attributes: {}, children: Array<JsxEl>)
}
```

The code below does the following:

1. moves the exercises to the end of the chapter
1. moves the solutions to the end of the book
1. Numbers the exercise
1. adds a link to the solution
1. numbers the solution
1. adds a link to the exercise


```jsx
theDocument.replace(`body`, () => {
    const solutionBucket = this.createBucket()
    const chapterCounter = this.createCounter(`[data-type="chapter"]`) // resets on `this` and increments on the selector
    
    this.replace(`[data-type="chapter"]`, () => {
        const chToken = this.countOf(chapterCounter)
        const exerciseBucket = this.createBucket()
        const exerciseCounter = this.createCounter(`[data-type="exercise"]`)

        this.replaceAndMove(exerciseBucket, `[data-type="exercise"]`, () => {
            const exToken = this.countOf(exerciseCounter)
            const toExercise = this.getHrefToMe() // uses the existing id attribute on `this` or autogenerates one
            const toSolution = this.find(`[data-type="solution"]`).getHrefToMe()

            this.replaceAndMove(solutionBucket, `[data-type="solution"]`, () => {
                <this>
                    <a href={toExercise}>{chToken}.{exToken}</a>
                    {...this.children}
                </this>
            })

            <this>
                <a href={toSolution}>{chToken}.{exToken}</a>
                {...this.children}
            </this>
        }))

        <this>
            <div>
                <title>Homework</title>
                {exerciseBucket.dump()}
            </div>
        </this>
    })

    <this>
        {...this.children}
        <section>
            <title>Answers</title>
            {solutionBucket.dump()}
        </section>
    </this>

})
```



Thoughts: Can multiple selectors apply to an element? Every element should have 0 or 1 selector that apply to it. If > 1 applies, that is an error (can't parallelize easily... but it is possible)
