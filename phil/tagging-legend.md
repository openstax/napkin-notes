Approach: Let's sculpt.


1. Large blobs: describe what unique information is needed
    - Tagging legend, recipe config, style config
    - Tool that generates a recipe
    - Tool that generates a CSS file
    - Tool that generates a CNXML validator
    - Tool that generates a Styleguide
1. Smaller blob: describe when we want things to error
    - When tagging legend changes
    - When recipe config changes
    - When style config changes
1. Other development features
    - when so many files are autogenerated do we need a way to go back to the source? Sourcemaps?
1. Discuss JSX & move to XSLT (templates, creating elements, slots that recurse)


# Spike idea

Below, I'm describing what is in the input files and what the output files should contain.

Currently, styling the content involves the following:

- a Tagging Legend Spreadsheet ([example](https://docs.google.com/spreadsheets/d/1vW0EHvn8fZgvTxZIm9xQXsqsnIDcolqwt5rWKtx4JEY/edit#gid=255572881))
- a Recipe ([example](https://github.com/openstax/cnx-recipes/blob/master/recipes/books/hs-physics/_config.scss))
- a PDF CSS ([example](https://github.com/openstax/cnx-recipes/blob/master/styles/books/hs-physics/book.scss))

These 3 things are kept in sync through popsicle sticks and duct tape, by humans.
It would be much nicer if machines could tell us when things need to change or update them automatically.

## Input Files

These are all human-edited "source of truth" files.

### Tagging legend

This should **only** define any book-specific markup in the CNXML.

```r
# File: physics.tagging

# *************************
# We define 2 Notes and a type of Exercise
# *************************

"checkUnderstanding" extends Note {
    attribute class = "check-understanding"
}

"tip" extends Note {
    attribute class = "tip"
}

"homeworkProblems" extends Exercise {
    attribute class = "homework-problems"
}
```

### Recipe config

This file(s) should **only** describe how elements are numbered, moved, or text that is injected (like titles)

```ts
// File: physics.recipe.ts
checkUnderstanding: {
    title: "Check Your Understanding",
    numbering: NONE
}
tip: {
    numbering: NONE
}
homeworkProblems: {
    title: "Homework Problems"
    moveTo: END_CHAPTER
}
```

### Style config

This file(s) should **only** describe how things in the book are styled. The things in a book are both book-specific features as well as generic book things (ToC, Index, Chapter Introduction, etc).

```ts
// File: physics.style.ts
checkUnderstanding.title.style = { color: blue }
homeworkProblems.style = {border: 1px solid green }
```

## Frameworks

These things are the helpers that convert the input files into the output files. They do not have anything that is book-specific in them.

- Recipe Framework
- Style Framework
- Styleguide generator
- Validation generator


## Output Files

These are files that we would like to be autogenerated from the input files.

The gist of each file is included as a comment at the top of the file.

### CNXML Validation

```xml
<!-- File: physics.cnxml.grammar.rng -->
<!-- **************************************************
    This says that valid notes in CNXML must have a 
    class="check-understanding" or class="tip".
    Any other type of note is invalid. 
    Same for exercises.
    ************************************************** -->
<r:grammar xmlns:r="http://relaxng.org/ns/structure/1.0">
    <r:define name="Content.Note">
        <r:element name="note">
            <r:attribute name="class">
                <r:choice>
                    <r:value>check-understanding</r:value>
                    <r:value>tip</r:value>
                </r:choice>
            </r:attribute>
        </r:element>
    </r:define>
    <r:define name="Content.Exercise">
        <r:element name="exercise">
            <r:attribute name="class">
                <r:choice>
                    <r:value>homework-problems</r:value>
                </r:choice>
            </r:attribute>
        </r:element>
    </r:define>
</r:grammar>
```

And we may want an autogenerated-but-human-readable version too... something like https://github.com/openstax/cnxml/pull/9

### Recipe

Here is an example autogenerated recipe that could be generated from the recipe config above. I'm using XSLT here because it's concise and looks JSX'y

```xml
<!-- File: physics.autogen.recipe.xsl -->
<!-- **************************************************
    This says that the following things will happen:
    
    - check-understanding notes will get a "Check Your Understanding" title.
    - check-understanding notes will not be numbered
    - other notes will be numbered as {chapter}.{note_number}
    - the end of the chapter will contain a new "Homework Problems" section
      - This section will contain all the exercises in the chapter that have
        class="homework-problems"
    - the homework-problems will be removed from their original location
      since they were moved into the end-of-chapter area
    ************************************************** -->
<xsl:template match="note[classContains(., 'check-understanding')]">
    <div class="check-understanding123">
        <h3>Check Your Understanding</h3>
        <xsl:recurse/>
    </div>
</xsl:template>

<xsl:template match="note[classContains(., 'check-understanding')]" mode="numberize"><!-- Do not add a number --></xsl:template>

<!-- just show that we number all other notes as 3.4 -->
<xsl:template match="note" mode="numberize">{key('chapter', .)}.{key('note', .)}</xsl:template>

<xsl:template match="chapter">
    <xsl:copy>
        <!-- ... slot that recursively does chapter stuff -->
        <xsl:recurse/>

        <!-- end-of-chapter areas -->
        <section class="homework-problems456-clump">
            <h2>Homework Problems</h2>
            <xsl:apply-templates select=".//exercise[classContains(., 'homework-problems')]"/>
        </section>
    </xsl:copy>
</xsl:template>

<xsl:template match="chapter//exercise[classContains(., 'homework-problems')]">
    <!-- this removes the exercise from the original location -->
</xsl:template>

<!-- xsl:recurse is just shorthand for `<xsl:apply-templates select="@*|node()"/>` -->
```

### Style CSS

```less
// physics-pdf.autogen.css
.check-understanding123 h3 { color: blue }
.homework-problems456 { border: 1px solid green }
```

### Styleguide

Here is what an example autogenerated styleguide could look like.
To create the file we need the following pieces of information:

- the tagging legend : to know all of the book-specific things in the markup
- a baked example of each item in the tagging legend
- the generated CSS so we can style the feature

```html
<head>
    <link rel="stylesheet" href="physics-pdf.autogen.css"/>
</head>
<body>
<article>
    <h1>Here is what a "check-understanding" Note looks like</h1>

    <div class="check-understanding123">
        <h3>Check Your Understanding</h3>
        Lorem ipsum Non ea vel et aut nihil amet voluptatem eos. Veritatis impedit repellendus eius repellendus eaque quidem. Iure quo reiciendis atque aliquam quidem. Sed suscipit dolorum nisi sequi. Quo et eum dicta blanditiis et et dolore magnam
    </div>
</article>

<article>
    <h1>Here is what a "homework-problems" Exercise will look like</h1>

    <section class="homework-problems456-clump">
        <h2>Homework Problems</h2>
        <div class="homework-problems456">
            <div data-type="problem">
                Lorem ipsum Non ea vel et aut nihil amet voluptatem eos. Veritatis impedit repellendus eius repellendus eaque quidem. Iure quo reiciendis atque aliquam quidem. Sed suscipit dolorum nisi sequi. Quo et eum dicta blanditiis et et dolore magnam
            </div>
        </div>
    </section>
</article>
```

---

# Another Replacer Draft

Thomas, Phil, and Publishers in general have come to the conclusion that book transformations are described by selecting an element and replacing it with something else.

The publishing industry has created and continues to use XSLT for the exact purpose of transforming XML content.

Our recipes do not need to be Turing-complete. The ways we manipulate our books useually comes from selecting from a few options. For example, Book A has tables with captions below the table and a title on top while Book B has tables with the title and caption on top. 

A full-fledged programming language is overkill and actually makes development harder because there are an infinite number of ways to move a caption to the top of the table. Instead, I propose 2 things:

1. a recipe config file and a code-generator (with source maps back to the config file).
1. the autogenerated code is written in a Replacer format

https://github.com/philschatz/ktchn

By starting with an XML format, if we choose to use a programming language directly (e.g. TypeScript) It would be almost trivial to either parse the XML or autogenerate the TypeScript.


## Converting XML to TypeSCript

This is described backwards... showing the TypeScript first, followed by the XML to help clarify how pieces are related.

Here are the types:

```typescript
interface DomEl {
    // Replace anything that matches sel with the result of `cb()`
    replace(sel: String, cb: CallbackFn)
    
    // Same as replace(...) but move the result into the bucket
    replaceAndMove(b: Bucket, sel: String, cb: CallbackFn)
    
    // Creates a bucket that will be filled and must be used
    createBucket(): Bucket
    
    // Creates a counter that resets at `this` and increments whenever `sel` occurs
    createCounter(sel: String): Counter

    // Determines the number that should be shown 
    countOf(c: Coutner): TokenFn

    // uses the id attribute to construct `#{this.attributes['id']}` or generates an id attribute if one does not exist
    getHrefToMe(): String

    find(sel: String): DomEl
}

type CallbackFn = (this: DomEl) => void
type TokenFn = () => string

type Counter = {} // Opaque; just a token/symbol for the user

interface Bucket {
    dump(): Array<JsxEl>
}

interface JsxEl {
    constructor(el: DomEl, attributes: {}, children: Array<JsxEl>)
}
```

The code below does the following:

1. moves the exercises to the end of the chapter
1. moves the solutions to the end of the book
1. Numbers the exercise
1. adds a link to the solution
1. numbers the solution
1. adds a link to the exercise


```jsx
theDocument.replace(`body`, () => {
    const solutionBucket = this.createBucket()
    const chapterCounter = this.createCounter(`[data-type="chapter"]`) // resets on `this` and increments on the selector
    
    this.replace(`[data-type="chapter"]`, () => {
        const chToken = this.countOf(chapterCounter)
        const exerciseBucket = this.createBucket()
        const exerciseCounter = this.createCounter(`[data-type="exercise"]`)

        this.replaceAndMove(exerciseBucket, `[data-type="exercise"]`, () => {
            const exToken = this.countOf(exerciseCounter)
            const toExercise = this.getHrefToMe() // uses the existing id attribute on `this` or autogenerates one
            const toSolution = this.find(`[data-type="solution"]`).getHrefToMe()

            this.replaceAndMove(solutionBucket, `[data-type="solution"]`, () => {
                <this>
                    <a href={toExercise}>{chToken}.{exToken}</a>
                    {...this.children}
                </this>
            })

            <this>
                <a href={toSolution}>{chToken}.{exToken}</a>
                {...this.children}
            </this>
        }))

        <this>
            <div>
                <title>Homework</title>
                {exerciseBucket.dump()}
            </div>
        </this>
    })

    <this>
        {...this.children}
        <section>
            <title>Answers</title>
            {solutionBucket.dump()}
        </section>
    </this>

})
```

## XML Version

This is an XML-only version of the recipe described above.

```xml
<r:root xmlns:r="urn:replacer-xml" xmlns="http://www.w3.org/1999/xhtml">

    <r:replace selector="body">
        <r:bucket name="solution"/>
        <r:coutner name="chapterCounter" selector="[data-type='chapter']"/>
        
        <r:replace selector="[data-type='chapter']">
            <r:token name="chToken" count-of="chapterCounter"/><!-- weird... come up wiith a better name -->
            <r:bucket name="exercise"/>
            <r:counter name="exerciseCounter" selector="[data-type='exercise']"/>

            <r:replace move-to="exerciseBucket" selector="[data-type='exercise']">
                <r:token name="exToken" count-of="exerciseCounter"/>
                <r:href-to-me name="toExercise"/>
                <r:variable name="toSolution">
                    <r:find selector="[data-type='solution']">
                        <r:href-to-me/>
                    </r:find>
                </r:variable>

                <r:replace move-to="solutionBucket" selector="[data-type='solution']">
                    <r:this>
                        <a href="{toExercise}">{chToken}.{exToken}</a>
                        <r:children/>
                    </r:this>
                </r:replace>

                <r:this>
                    <a href={toSolution}>{chToken}.{exToken}</a>
                    <r:children/>
                </r:this>
            </r:replace>

            <r:this>
                <div>
                    <title>Homework</title>
                    {exerciseBucket.dump()}
                </div>
            </r:this>
        </r:replace>

        <r:this>
            <r:children/>
            <section>
                <title>Answers</title>
                {solutionBucket.dump()}
            </section>
        </r:this>

    </r:replace>

</r:root>
```



Thoughts: Can multiple selectors apply to an element? Every element should have 0 or 1 selector that apply to it. If > 1 applies, that is an error (can't parallelize easily... but it is possible)
